% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filter_data.R
\name{filter_data}
\alias{filter_data}
\title{Filter Data}
\usage{
filter_data(
  x,
  method = c("smooth-spline", "butter", "moving-average"),
  type = c("low", "high", "stop", "pass"),
  spar = NULL,
  n = 1,
  W,
  critical_frequency,
  sample_rate,
  width
)
}
\arguments{
\item{x}{A numeric vector.}

\item{method}{Indicates how to filter the data (see \emph{Details}).
\describe{
\item{\code{"smooth-spline"}}{fits a cubic smoothing spline.}
\item{\code{"butter"}}{uses a centred Butterworth digital filter. \code{type} should
be defined (see \emph{Details}).}
\item{\code{"moving-average"}}{uses a centred moving average filter.}
}}

\item{type}{Specify the filter type. \emph{Only relevant for \code{method = "butter"}}
(see \emph{Details}).
\describe{
\item{\code{"low"}}{For a \emph{low-pass} filter (\emph{default}).}
\item{\code{"high"}}{For a \emph{high-pass} filter.}
\item{\code{"stop"}}{For a \emph{stop-band} (band-reject) filter.}
\item{\code{"pass"}}{For a \emph{pass-band} filter.}
}}

\item{spar}{A numeric scalar defining the smoothing parameter for
\code{method = "smooth-spline"}.}

\item{n}{An integer scalar defining the order of a Butterworth filter for
\code{method = "butter"}.}

\item{W}{A numeric scalar or two-element vector defining the fractional
critical frequency(ies) of a Butterworth filter for \code{method = "butter"}.}

\item{critical_frequency}{A numeric scalar or two-element vector defining
the critical frequency(ies) of a Butterworth filter for \code{method = "butter"}.}

\item{sample_rate}{A numeric scalar for the sample rate in Hz for
\code{method = "butter"}.}

\item{width}{A numeric scalar defining the window length of samples for
\code{method = "moving-average"}.}
}
\value{
A numeric vector of filtered data.
}
\description{
Applies signal filtering with either: 1. A cubic smoothing spline.
2. A Butterworth digital filter. 3. A simple moving average.
}
\details{
\describe{
\item{\code{method = "smooth-spline"}}{applies a non-parametric cubic
smoothing spline from \code{\link[stats:smooth.spline]{stats::smooth.spline()}}. Smoothing is defined
by the parameter \code{spar}, which can be left blank and automatically
determined via penalised log liklihood. This usually works well for
smoothing responses occurring on the order of minutes or longer. Or \code{spar}
can be defined explicitly, typically (but not necessarily) in the range
\verb{spar = [0, 1]}.}

\if{html}{\out{<div class="sourceCode">}}\preformatted{ \\item\{`method = "butter"`\}\{applies a centred (two-pass symmetrical)
 Butterworth digital filter from [signal::butter()] and [signal::filtfilt()].
 The filter order is defined by `n`, typically in the range `n = [1, 10]`.
 Higher filter orders tend to better capture rapid changes in amplitude,
 but also cause more distortion artefacts in the signal. General advice is
 to use the lowest order which sufficiently captures any rapid step-changes
 in the data.

 Filter `type` defines how the desired signal frequencies are either passed
 through or rejected from the output signal. *Low-pass* and *high-pass*
 filters allow only frequencies *lower* or *higher* than the critical
 frequency `W` to be passed through as the output signal, respectively.
 *Stop-band* defines a critical range of frequencies which are rejected
 from the output signal. *Pass-band* defines a critical range of frequencies
 which are passed through as the output signal.

 The critical (cutoff) frequency is defined by `W`, a numeric scalar for
 *low-pass* and *high-pass* filters, or a two-element vector `c(low, high)`
 defining the lower and upper bands for *stop-band* and *pass-band* filters.
 `W` represents the desired fractional critical frequency in the range
 `W = [0, 1]`, where `1` is the Nyquist frequency, i.e., half the sample
 rate of the data in Hz.

 Alternatively, the critical frequency can be defined by `critical_frequency`
 and `sample_rate` together. `critical_frequency` represents the desired
 critical frequency in Hz, and `sample_rate` is the sample rate of the
 recorded data in Hz. `W = critical_frequency / (sample_rate/2)`.

 Defining both `critical_frequency` and `sample_rate` explicitly will
 overwrite `W`.\}

 \\item\{`method = "moving-average"`\}\{applies a centred (two-way symmetrical)
 moving average filter from [zoo::rollapply()]. The moving-average is
 calculated over a window of width `width` defining the number of samples
 between `[i - floor(width/2), i + floor(width/2)]`. A partial moving-
 average will be calculated at the edges of the existing data.\}
}\if{html}{\out{</div>}}

}
}
\examples{
set.seed(13)
n <- 500
x <- seq(0, 2*pi, len = n)
y_clean <- 2*sin(x)
noise <- rnorm(n, mean = 0, sd = 0.5)
y <- y_clean + noise

y.spline <- filter_data(y, method = "smooth-spline")
y.LP <- filter_data(y, method = "butter", n = 2, W = 0.05)
y.MA <- filter_data(y, method = "moving-average", width = 30)

plot(x, y)
lines(x, y.spline, lwd = 2, col = "blue")
lines(x, y.LP, lwd = 2, col = "red")
lines(x, y.MA, lwd = 2, col = "green4")

}
