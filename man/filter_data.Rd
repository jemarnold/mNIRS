% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filter_data.R
\name{filter_data}
\alias{filter_data}
\title{Filter Data}
\usage{
filter_data(
  x,
  method = c("smooth-spline", "low-pass", "moving-average"),
  spar = NULL,
  n = 4,
  W = 0.1,
  fc,
  sr,
  k = 15,
  ...
)
}
\arguments{
\item{x}{A numeric vector of mNIRS data.}

\item{method}{Indicates how to digitally filter the data.
\itemize{
\item \emph{"smooth-spline"} fits a cubic smoothing spline.
\item \emph{"low-pass"} uses a centred Butterworth low-pass filter.
\item \emph{"moving-average"} uses a centred moving average filter.
}}

\item{...}{Additional arguments.}
}
\value{
A numeric vector of filtered data.
}
\description{
Applies digital filtering with either:
\enumerate{
\item A cubic smoothing spline.
\item A Butterworth low-pass filter.
\item A simple moving average.
}
}
\details{
\code{method = "smooth-spline"} applies a non-parametric cubic smoothing spline
from \code{\link[stats:smooth.spline]{stats::smooth.spline()}}. Smoothing is defined by the parameter
\code{spar}, a numeric scalar which can be left blank and automatically
determined via penalised log liklihood. This usually works well for
smoothing responses occuring on the order of minutes or longer. Or \code{spar}
can be defined explicitly, typically (but not necessarily) \verb{spar = [0, 1]}.

\code{method = "low-pass"} applies a centred (two-pass symmetrical) Butterworth
low-pass digital filter from \code{\link[signal:butter]{signal::butter()}} and \code{\link[signal:filtfilt]{signal::filtfilt()}}.
The filter order is defined by \code{n}, an integer scalar typically \verb{n = [1, 10]}.
Higher filter orders tend to capture rapid changes in amplitude better, but
also cause more distortion artefacts in the signal. General advice is to use
the lowest order that sufficiently captures rapid step-changes in the data.

The low frequencies to be passed through the filter are defined by a
critical frequency. This can be defined by either \code{fc}, a numeric scalar
representing the desired critical frequency in Hz, and \code{sr}, a numeric
scalar reflecting the sample rate of the data in Hz together. Or by \code{W},
a numeric scalar representing the desired fractional critical frequency
between \verb{[0, 1]}, where \code{1} is the Nyquist frequency, i.e., half the sample
rate of the data in Hz.

Defining both \code{fc} and \code{sr} explicitly will overwrite \code{W}.

\code{method = "moving-average"} applies a centred (two-way symmetrical) moving
average filter from \code{\link[zoo:rollapply]{zoo::rollapply()}}. The moving-average is calculated
over a window of width \code{k}, an integer scalar specifying the number of
samples between \verb{[i - floor(k/2), i + floor(k/2)]}. A partial moving-average
will be calculated at the edges of the existing data.
}
