file_path = r"(C:\OneDrive - UBC\Group Projects\JAData\DataAverage-VMPro-2023-05-17.xlsx)",
nirs_columns = c("right_smo2" = "SmO2[%]",
"left_smo2" = "SmO2 -  2[%]",
"thb" = "THb[THb]"),
sample_column = c("time" = "Time[hh:mm:ss]"),
event_column = NULL,
.keep_all = FALSE)
# mNIRS::read_data(
#     file_path = "C:/OneDrive - UBC/Body Position Study/Raw Data/BP01-Train.Red-2025-04-01.csv",
#     nirs_columns = c("smo2_left" = "SmO2 unfiltered",
#                      # "HHb" = "HHb unfiltered",
#                      # "O2Hb" = "O2HB unfiltered",
#                      "smo2_right" = "SmO2 unfiltered"),
#     sample_column = c("time" = "Timestamp (seconds passed)"),
#     event_column = c("Lap/Event"))
#
## Oxysoft
mNIRS::read_data(
file_path = "C:/OneDrive - UBC/Body Position Study/Raw Data/BP01-oxysoft-2025-04-01.xlsx",
nirs_columns = c("PS_O2Hb" = "2",
"PS_HHb" = "3",
"VL_O2Hb" = "5",
"VL_HHb" = "6"),
sample_column = c("sample" = "1"),
event_column = c("event" = "10", "label" = "...11"),
.keep_all = TRUE)
file_path = "C:/OneDrive - UBC/Body Position Study/Raw Data/BP01-oxysoft-2025-04-01.xlsx"
file_path = "C:/OneDrive - UBC/Body Position Study/Raw Data/BP01-oxysoft-2025-04-01.xlsx"
file_path = "C:/OneDrive - UBC/Body Position Study/Raw Data/BP01-oxysoft-2025-04-01.xlsx"
nirs_columns = c("PS_O2Hb" = "2",
"PS_HHb" = "3",
"VL_O2Hb" = "5",
"VL_HHb" = "6")
sample_column = c("sample" = "1")
event_column = c("event" = "10", "label" = "...11")
.keep_all = FALSE
## import from either excel or csv
## report error when file is open and cannot be opened by readxl
if (grepl("xls(x)?", tools::file_ext(file_path))) {
raw_data_pre <- tryCatch({
readxl::read_excel(
path = file_path, col_names = FALSE, col_types = "text",
n_max = 1000) |>
suppressMessages()
}, error = \(e) {
if (stringr::str_detect(e$message, "cannot be opened")) {
cli::cli_abort(paste(
"{e} \n",
"{.arg file_path} = {.file {file_path}}",
"cannot be opened, likely because the file is in use."
))
} else {stop(e)}
})
## detect row where nirs_columns exists, assuming this is common header
## row for dataframe
header_row <- which(apply(
raw_data_pre[1:1000, ], 1,
\(row) all(nirs_columns %in% row)))
} else if (grepl("csv", tools::file_ext(file_path))) {
all_lines <- readLines(file_path, warn = FALSE)
header_row <- which(
Reduce(`&`, lapply(nirs_columns, grepl, x = all_lines)))
raw_data_pre <- data.table::fread(file_path, fill = Inf) |>
tibble::as_tibble()
}
## validation: nirs_columns must be detected to extract the proper
## dataframe
if (rlang::is_empty(header_row)) {
cli::cli_abort(paste(
"{.arg nirs_columns} = `{.val {nirs_columns}}` {?was/were}",
"not detected in the data."))
}
## return error if nirs_columns string is detected multiple times
if (length(header_row) > 1) {
cli::cli_abort(paste(
"{.arg nirs_columns} = `{.val {nirs_columns}}` {?was/were}",
"detected at multiple locations. Please ensure that the names",
"in {.arg nirs_columns} are uniquely identifiable."))
}
## import from either excel or csv
## re-read the data at the proper row to extract the dataframe
if (stringr::str_ends(file_path, ".xls|.xlsx")) {
raw_data_trimmed <- readxl::read_excel(
path = file_path, skip = header_row - 1,
guess_max = 50000, na = c("", "NA")
) |>
## drops columns where all NA or 0
dplyr::select(dplyr::where(\(.x) !all(is.na(.x) | .x == 0))) |>
## drops rows where all NA
dplyr::filter(
dplyr::if_any(dplyr::everything(), \(.x) !is.na(.x))
) |>
suppressMessages()
} else if (stringr::str_ends(file_path, ".csv")) {
raw_data_trimmed <- utils::read.csv(
file = file_path, skip = header_row - 1,
check.names = FALSE, na.strings = c("", "NA")
) |>
tibble::as_tibble(.name_repair = "unique") |>
## drops columns where all NA or 0
dplyr::select(dplyr::where(\(.x) !all(is.na(.x) | .x == 0))) |>
## drops rows where all NA
dplyr::filter(
dplyr::if_any(dplyr::everything(), \(.x) !is.na(.x))
) |>
suppressMessages()
}
raw_data_trimmed
## rename named column vectors
rename_column_function <- function(colnames) {
names(colnames) <- if (!is.null(names(colnames))) {
replace(names(colnames),
names(colnames) == "",
colnames[names(colnames) == ""])
} else {colnames}
return(colnames)
}
nirs_columns
nirs_columns <- rename_column_function(nirs_columns)
nirs_columns
nirs_columns <- rename_column_function(nirs_columns)
sample_column <- rename_column_function(sample_column)
event_column <- rename_column_function(event_column)
## validation: check that sample_column and event_column
if (!is.null(sample_column)) {
if (!all(sample_column %in% names(raw_data_trimmed))) {
cli::cli_abort(paste(
"{.arg sample_column} = `{.val {sample_column}}` not detected.",
"Column names are case sensitive and should match exactly."))
}}
if (!is.null(event_column)) {
if (!all(event_column %in% names(raw_data_trimmed))) {
cli::cli_abort(paste(
"{.arg event_column} = `{.val {event_column}}` not detected.",
"Column names are case sensitive and should match exactly."))
}}
match_columns <- function(name_vector) {
## Get the base names (without suffixes) of dataframe columns
base_names <- gsub("\\.\\.\\.[0-9]+$", "", names(raw_data_trimmed))
## Initialize result vector
matched_cols <- character(length(name_vector)) |>
setNames(names(name_vector))
## Track which columns have been matched already
used_cols <- logical(length(names(raw_data_trimmed)))
## For each name in the input vector
for (i in seq_along(name_vector)) {
target_name <- name_vector[i]
## Find indices of columns with matching base name
## which haven't been used yet
matching_indices <- which(base_names == target_name & !used_cols)
if (length(matching_indices) > 0) {
## Take the first available match
matched_cols[i] <- names(raw_data_trimmed)[matching_indices[1]]
## Mark this column as used
used_cols[matching_indices[1]] <- TRUE
} else {
## No matching column found
matched_cols[i] <- NA_character_
}
}
return(matched_cols)
}
nirs_columns
nirs_columns <- match_columns(nirs_columns)
nirs_columns
nirs_columns <- match_columns(nirs_columns)
sample_column <- match_columns(sample_column)
event_column <- match_columns(event_column)
raw_data_prepared <- raw_data_trimmed |>
## keep_all selects everything, else only manual columns
dplyr::select(
dplyr::any_of(c(
sample_column,
event_column,
nirs_columns)),
if (.keep_all) dplyr::everything()
) |>
## rename columns from manual input
dplyr::rename(
dplyr::any_of(c(
nirs_columns,
sample_column,
event_column))
) |>
## drops columns where all(is.na()) or all(.==0) values
dplyr::select(dplyr::where(\(.x) !all(is.na(.x) | .x == 0))) |>
dplyr::mutate(
## convert blank values to NA
dplyr::across(
dplyr::where(is.numeric),
\(.x) ifelse(.x %in% c(Inf, -Inf, NaN), NA_real_, .x)),
dplyr::across(
dplyr::where(is.character),
\(.x) ifelse(.x %in% c("", "NA"), NA_character_, .x)),
) |>
( \(df) {
## drops rows after the first row where all(is.na())
## c(..., 0) ensures the last row will be taken when no rows
## are all(is.na)
first_allna_row <- which(
diff(c(rowSums(is.na(df)) != ncol(df), 0)) != 0)[1]
dplyr::slice_head(df, n = first_allna_row)
})() |>
dplyr::mutate(
## convert sample column to unique numeric values in seconds
## https://github.com/fmmattioni/whippr/blob/master/R/read-data.R
## detects either character or dttm formats
## tested on Moxy, PerfPro, Oxysoft, VMPro x2
## TODO test on Train.Red, NNOXX, Graspor, Oxysoft csv, ...
dplyr::across(
dplyr::any_of(names(sample_column)) &
dplyr::where(is.character),
\(.x) as.POSIXct(.x, tryFormats = c(
"%Y-%m-%d %H:%M:%OS", "%Y/%m/%d %H:%M:%OS", "%H:%M:%OS"),
format = "%H:%M:%OS")),
## adds a sequential index column
dplyr::across(
dplyr::any_of(names(nirs_columns[1])),
\(.x) seq_along(.x),
.names = "index"),
) |>
dplyr::relocate(index)
raw_data_trimmed |>
## keep_all selects everything, else only manual columns
dplyr::select(
dplyr::any_of(c(
sample_column,
event_column,
nirs_columns)),
if (.keep_all) dplyr::everything()
)
raw_data_trimmed
c(
sample_column,
event_column,
nirs_columns)
match_columns <- function(name_vector) {
## Get the base names (without suffixes) of dataframe columns
base_names <- gsub("(?<!^)\\.\\.\\.[0-9]+$", "", names(raw_data_trimmed))
## Initialize result vector
matched_cols <- character(length(name_vector)) |>
setNames(names(name_vector))
## Track which columns have been matched already
used_cols <- logical(length(names(raw_data_trimmed)))
## For each name in the input vector
for (i in seq_along(name_vector)) {
target_name <- name_vector[i]
## Find indices of columns with matching base name
## which haven't been used yet
matching_indices <- which(base_names == target_name & !used_cols)
if (length(matching_indices) > 0) {
## Take the first available match
matched_cols[i] <- names(raw_data_trimmed)[matching_indices[1]]
## Mark this column as used
used_cols[matching_indices[1]] <- TRUE
} else {
## No matching column found
matched_cols[i] <- NA_character_
}
}
return(matched_cols)
}
match_columns(sample_column)
match_columns <- function(name_vector) {
## Get the base names (without suffixes) of dataframe columns
base_names <- gsub("(?<!^)\\.\\.\\.[0-9]+$", "",
names(raw_data_trimmed),
perl = TRUE)
## Initialize result vector
matched_cols <- character(length(name_vector)) |>
setNames(names(name_vector))
## Track which columns have been matched already
used_cols <- logical(length(names(raw_data_trimmed)))
## For each name in the input vector
for (i in seq_along(name_vector)) {
target_name <- name_vector[i]
## Find indices of columns with matching base name
## which haven't been used yet
matching_indices <- which(base_names == target_name & !used_cols)
if (length(matching_indices) > 0) {
## Take the first available match
matched_cols[i] <- names(raw_data_trimmed)[matching_indices[1]]
## Mark this column as used
used_cols[matching_indices[1]] <- TRUE
} else {
## No matching column found
matched_cols[i] <- NA_character_
}
}
return(matched_cols)
}
match_columns(nirs_columns)
nirs_columns = c("PS_O2Hb" = "2",
"PS_HHb" = "3",
"VL_O2Hb" = "5",
"VL_HHb" = "6")
sample_column = c("sample" = "1")
event_column = c("event" = "10", "label" = "...11")
match_columns <- function(name_vector) {
## Get the base names (without suffixes) of dataframe columns
base_names <- gsub("(?<!^)\\.\\.\\.[0-9]+$", "",
names(raw_data_trimmed),
perl = TRUE)
## Initialize result vector
matched_cols <- character(length(name_vector)) |>
setNames(names(name_vector))
## Track which columns have been matched already
used_cols <- logical(length(names(raw_data_trimmed)))
## For each name in the input vector
for (i in seq_along(name_vector)) {
target_name <- name_vector[i]
## Find indices of columns with matching base name
## which haven't been used yet
matching_indices <- which(base_names == target_name & !used_cols)
if (length(matching_indices) > 0) {
## Take the first available match
matched_cols[i] <- names(raw_data_trimmed)[matching_indices[1]]
## Mark this column as used
used_cols[matching_indices[1]] <- TRUE
} else {
## No matching column found
matched_cols[i] <- NA_character_
}
}
return(matched_cols)
}
match_columns(nirs_columns)
match_columns(sample_column)
match_columns(event_column)
nirs_columns <- match_columns(nirs_columns)
sample_column <- match_columns(sample_column)
event_column <- match_columns(event_column)
raw_data_prepared <- raw_data_trimmed |>
## keep_all selects everything, else only manual columns
dplyr::select(
dplyr::any_of(c(
sample_column,
event_column,
nirs_columns)),
if (.keep_all) dplyr::everything()
) |>
## rename columns from manual input
dplyr::rename(
dplyr::any_of(c(
nirs_columns,
sample_column,
event_column))
) |>
## drops columns where all(is.na()) or all(.==0) values
dplyr::select(dplyr::where(\(.x) !all(is.na(.x) | .x == 0))) |>
dplyr::mutate(
## convert blank values to NA
dplyr::across(
dplyr::where(is.numeric),
\(.x) ifelse(.x %in% c(Inf, -Inf, NaN), NA_real_, .x)),
dplyr::across(
dplyr::where(is.character),
\(.x) ifelse(.x %in% c("", "NA"), NA_character_, .x)),
) |>
( \(df) {
## drops rows after the first row where all(is.na())
## c(..., 0) ensures the last row will be taken when no rows
## are all(is.na)
first_allna_row <- which(
diff(c(rowSums(is.na(df)) != ncol(df), 0)) != 0)[1]
dplyr::slice_head(df, n = first_allna_row)
})() |>
dplyr::mutate(
## convert sample column to unique numeric values in seconds
## https://github.com/fmmattioni/whippr/blob/master/R/read-data.R
## detects either character or dttm formats
## tested on Moxy, PerfPro, Oxysoft, VMPro x2
## TODO test on Train.Red, NNOXX, Graspor, Oxysoft csv, ...
dplyr::across(
dplyr::any_of(names(sample_column)) &
dplyr::where(is.character),
\(.x) as.POSIXct(.x, tryFormats = c(
"%Y-%m-%d %H:%M:%OS", "%Y/%m/%d %H:%M:%OS", "%H:%M:%OS"),
format = "%H:%M:%OS")),
## adds a sequential index column
dplyr::across(
dplyr::any_of(names(nirs_columns[1])),
\(.x) seq_along(.x),
.names = "index"),
) |>
dplyr::relocate(index)
mNIRS::read_data(
file_path = "C:/OneDrive - UBC/Body Position Study/Raw Data/BP01-oxysoft-2025-04-01.xlsx",
nirs_columns = c("PS_O2Hb" = "2",
"PS_HHb" = "3",
"VL_O2Hb" = "5",
"VL_HHb" = "6"),
sample_column = c("sample" = "1"),
event_column = c("event" = "10", "label" = "...11"),
.keep_all = FALSE)
#          file_path = r"(C:\OneDrive - UBC\5-1 Assessments\Processed Data\03-2_2021-08-10-data.xlsx)",
#          nirs_columns = c("smo2_right_VL", "smo2_left_VL"),
#          sample_column = "Time",
#          event_column = NULL) |>
#      dplyr::mutate(event = dplyr::if_else(index %in% c(3009), "reoxy", NA)) |>
#      # dplyr::filter(index >= 2340, index <= 2590) |>
#      dplyr::filter(index >= 2980, index <= 3050) |> ## reoxy
#      dplyr::mutate(index = index - dplyr::first(index))
#  )
# #
read_data(
file_path = r"(C:\OneDrive - UBC\FLIA Clinical Assessments\Raw Data\CSIO-LGC-2024-1126.xlsx)",
nirs_columns = c("SmO2" = "SmO2 Live", "SmO2 Averaged", "total[heme]" = "THb"),
sample_column = c("Time" = "hh:mm:ss"),
event_column = NULL,
.keep_all = TRUE)
read_data(
file_path = r"(C:\OneDrive - UBC\Group Projects\JAData\1619.csv)",
nirs_columns = c("SmO2 Live", "SmO2 Averaged", "THb"),
sample_column = c("time" = "hh:mm:ss"),
event_column = NULL)
# #
#
# ## Moxy
# read_data(
#     file_path = r"(C:\OneDrive - UBC\Group Projects\JAData\1619.csv)",
#     nirs_columns = c("SmO2 Live", "SmO2 Averaged", "THb"),
#     sample_column = c("time" = "hh:mm:ss"),
#     event_column = NULL)
# #
# # ## PerfPro
read_data(
file_path = r"(C:\OneDrive - UBC\Group Projects\JAData\Treadmill-VO2max-PerfPro-2024-12-16.xlsx)",
nirs_columns = "smo2_left_VL",
sample_column = "Time",
event_column = NULL)
#     event_column = NULL)
# #
# # ## PerfPro
# read_data(
#     file_path = r"(C:\OneDrive - UBC\Group Projects\JAData\Treadmill-VO2max-PerfPro-2024-12-16.xlsx)",
#     nirs_columns = "smo2_left_VL",
#     sample_column = "Time",
#     event_column = NULL)
# #
# # ## Artinis Oxysoft
read_data(
file_path = r"(C:\OneDrive - UBC\Body Position Study\Raw Data\SRLB02-Oxysoft-2024-12-20.xlsx)",
nirs_columns = "HHb",
sample_column = "time",
event_column = "event")
#     event_column = NULL)
# #
# # ## PerfPro
# read_data(
#     file_path = r"(C:\OneDrive - UBC\Group Projects\JAData\Treadmill-VO2max-PerfPro-2024-12-16.xlsx)",
#     nirs_columns = "smo2_left_VL",
#     sample_column = "Time",
#     event_column = NULL)
# #
# # ## Artinis Oxysoft
read_data(
file_path = r"(C:\OneDrive - UBC\Body Position Study\Raw Data\SRLB02-Oxysoft-2024-12-20.xlsx)",
nirs_columns = c("HHb" = "6"),
sample_column = "time",
event_column = "event")
#     event_column = NULL)
# #
# # ## PerfPro
# read_data(
#     file_path = r"(C:\OneDrive - UBC\Group Projects\JAData\Treadmill-VO2max-PerfPro-2024-12-16.xlsx)",
#     nirs_columns = "smo2_left_VL",
#     sample_column = "Time",
#     event_column = NULL)
# #
# # ## Artinis Oxysoft
read_data(
file_path = r"(C:\OneDrive - UBC\Body Position Study\Raw Data\SRLB02-Oxysoft-2024-12-20.xlsx)",
nirs_columns = c("HHb" = "6", "O2Hb" = "7"),
sample_column = "time",
event_column = "event")
#     event_column = NULL)
# #
# # ## PerfPro
# read_data(
#     file_path = r"(C:\OneDrive - UBC\Group Projects\JAData\Treadmill-VO2max-PerfPro-2024-12-16.xlsx)",
#     nirs_columns = "smo2_left_VL",
#     sample_column = "Time",
#     event_column = NULL)
# #
# # ## Artinis Oxysoft
read_data(
file_path = r"(C:\OneDrive - UBC\Body Position Study\Raw Data\SRLB02-Oxysoft-2024-12-20.xlsx)",
nirs_columns = c("HHb" = "6", "O2Hb" = "7"),
sample_column = c("sample" = "1"),
event_column = "event")
#     event_column = NULL)
# #
# # ## PerfPro
# read_data(
#     file_path = r"(C:\OneDrive - UBC\Group Projects\JAData\Treadmill-VO2max-PerfPro-2024-12-16.xlsx)",
#     nirs_columns = "smo2_left_VL",
#     sample_column = "Time",
#     event_column = NULL)
# #
# # ## Artinis Oxysoft
read_data(
file_path = r"(C:\OneDrive - UBC\Body Position Study\Raw Data\SRLB02-Oxysoft-2024-12-20.xlsx)",
nirs_columns = c("HHb" = "6", "O2Hb" = "7"),
sample_column = c("sample" = "1"),
event_column = c("event" = "10"))
1/0.56
1/1.78
round(0.56/5)*5
round(0.56*5)/5
round(0.56/0.5)*0.5
round(10.1/0.5)*0.5
