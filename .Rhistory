.x=c(1:20)
fixed_values=c(8)
k = 4
for (i in (k + 1):(n - k)) {
x0 <- median(.x[(i - k):(i + k)])
# print(x0)
if (.x[i] %in% fixed_values) {
y[i] <- if (return == "median") {x0} else {NA_real_}
idx <- c(idx, i)
print(y[i])
}
}
n <- length(.x)
y <- .x
idx <- c()
for (i in (k + 1):(n - k)) {
x0 <- median(.x[(i - k):(i + k)])
# print(x0)
if (.x[i] %in% fixed_values) {
y[i] <- if (return == "median") {x0} else {NA_real_}
idx <- c(idx, i)
print(y[i])
}
}
return = "median"
for (i in (k + 1):(n - k)) {
x0 <- median(.x[(i - k):(i + k)])
# print(x0)
if (.x[i] %in% fixed_values) {
y[i] <- if (return == "median") {x0} else {NA_real_}
idx <- c(idx, i)
print(y[i])
}
}
for (i in (k + 1):(n - k)) {
x0 <- median(.x[(i - k):(i + k)])
print(x0)
if (.x[i] %in% fixed_values) {
y[i] <- if (return == "median") {x0} else {NA_real_}
idx <- c(idx, i)
print(y[i])
}
}
replace_fixed_values(.x= sample.int(40, 100, replace = TRUE), fixed_values=c(8), k = 4)
set.seed(13)
sample.int(40, 100, replace = TRUE)
replace_fixed_values(.x= sample.int(40, 100, replace = TRUE), fixed_values=c(8), k = 4)
set.seed(13)
.x <- sample.int(40, 100, replace = TRUE)
set.seed(13)
(.x <- sample.int(40, 100, replace = TRUE))
replace_fixed_values(.x, fixed_values=c(8), k = 4)
set.seed(13)
(.x <- sample.int(40, 100, replace = TRUE))
replace_fixed_values(.x, fixed_values=c(8), k = 10)
set.seed(12)
(.x <- sample.int(40, 100, replace = TRUE))
replace_fixed_values(.x, fixed_values=c(8), k = 10)
set.seed(11)
(.x <- sample.int(40, 100, replace = TRUE))
replace_fixed_values(.x, fixed_values=c(8), k = 10)
set.seed(11)
(.x <- sample.int(20, 40, replace = TRUE))
replace_fixed_values(.x, fixed_values=c(8), k = 10)
set.seed(11)
(.x <- sample.int(20, 40, replace = TRUE))
(y <- replace_fixed_values(.x, fixed_values=c(8), k = 10))
y == x
set.seed(11)
(.x <- sample.int(20, 40, replace = TRUE))
(y <- replace_fixed_values(.x, fixed_values=c(8), k = 10))
y == .x
set.seed(11)
(.x <- sample.int(20, 40, replace = TRUE))
(y <- replace_fixed_values(.x, fixed_values=c(8), k = 10)$y)
y == .x
#' ## Not run:
#' plot(1:1024, .x, type="l")
#' points(omad$idx, .x[omad$idx], pch=21, col="darkred")
#' grid()
#' ## End(Not run)
#'
#' @return A list `L` with `L$y` the corrected time series and
#' `L$idx` the indices of outliers in the *"median absolute deviation"* sense.
#'
#' @export
replace_outliers <- function(
.x,
k,
t0 = 3,
na.rm = FALSE,
return = c("median", "NA")
) {
return <- match.arg(return)
## validation: `k` must be a numeric scalar
if (!rlang::is_double(k) | length(k) > 1) {
cli::cli_abort(paste("{.arg k} must be a {.cls numeric} scalar."))
}
## validation: `k` must be shorter than .x
if (k >= ceiling(length(.x)/2)) {
cli::cli_abort(paste("{.arg k} must be 1/2 the length of {.arg .x}."))
}
## validation: `t0` must be a numeric scalar
if (!rlang::is_double(t0) | length(t0) > 1) {
cli::cli_abort(paste("{.arg t0} must be a {.cls numeric} scalar."))
}
x.all <- setNames(.x, seq_along(.x))
.x <- if (na.rm) {na.omit(x.all)} else {x.all}
n <- length(.x)
y <- .x
idx <- c()
L <- 1.4826
for (i in (k + 1):(n - k)) {
x0 <- median(.x[(i - k):(i + k)])
S0 <- L * median(abs(.x[(i - k):(i + k)] - x0))
if (abs(.x[i] - x0) > t0 * S0) {
y[i] <- if (return == "median") {x0} else {NA_real_}
idx <- c(idx, i)
}
}
y.idx <- as.numeric(names(y[idx]))
x.all[y.idx] <- y[idx]
list(y = x.all, idx = y.idx)
}
(y <- replace_outliers(.x, k = 10)$y)
set.seed(8421)
.x <- numeric(1024)
z <- rnorm(1024)
.x[1] <- z[1]
for (i in 2:1024) {
.x[i] <- 0.4*.x[i-1] + 0.8*.x[i-1]*z[i-1] + z[i]
}
.x[100:200] <- NA
omad <- replace_outliers(.x, k = 20, na.rm = TRUE)
## Not run:
plot(1:1024, .x, type="l")
points(omad$idx, .x[omad$idx], pch=21, col="darkred")
grid()
(.x <- c(2,NA,1,4,5,2))
zoo::na.locf(.x)
#' to fill. Any longer gaps will be left unchanged.
#' @param ... Additional arguments.
#'
#' @details
#'
#'
#' @return A list `L` with `L$y` the corrected time series and
#' `L$idx` the indices of the values replaced.
#'
#' @export
replace_missing_data <- function(
.x,
method = c("locf", "linear", "spline"),
rule = 2,
na.rm = TRUE,
maxgap = Inf,
...
) {
## TODO
## na.locf() stands for last observation carried forward
## na.approx() uses linear interpolation
## na.spline() uses spline interpolation
method <- match.arg(method)
if (method == "locf") {
y <- zoo::na.locf(.x, rule = rule, na.rm = na.rm, maxgap = maxgap)
} else if (method == "linear") {
y <- zoo::na.approx(.x, rule = rule, na.rm = na.rm, maxgap = maxgap)
} else if (method == "spline") {
y <- zoo::na.spline(.x, rule = rule, na.rm = na.rm, maxgap = maxgap)
}
}
replace_missing_data(.x)
#' to fill. Any longer gaps will be left unchanged.
#' @param ... Additional arguments.
#'
#' @details
#'
#'
#' @return A list `L` with `L$y` the corrected time series and
#' `L$idx` the indices of the values replaced.
#'
#' @export
replace_missing_data <- function(
.x,
method = c("locf", "linear", "spline"),
rule = 2,
na.rm = TRUE,
maxgap = Inf,
...
) {
## TODO
## na.locf() stands for last observation carried forward
## na.approx() uses linear interpolation
## na.spline() uses spline interpolation
method <- match.arg(method)
if (method == "locf") {
y <- zoo::na.locf(.x, rule = rule, na.rm = na.rm, maxgap = maxgap)
} else if (method == "linear") {
y <- zoo::na.approx(.x, rule = rule, na.rm = na.rm, maxgap = maxgap)
} else if (method == "spline") {
y <- zoo::na.spline(.x, rule = rule, na.rm = na.rm, maxgap = maxgap)
}
return(y)
}
replace_missing_data(.x)
replace_missing_data(.x, "linear")
replace_missing_data(.x, "spline")
#' to fill. Any longer gaps will be left unchanged.
#' @param ... Additional arguments.
#'
#' @details
#'
#'
#' @return A list `L` with `L$y` the corrected time series and
#' `L$idx` the indices of the values replaced.
#'
#' @export
replace_missing_data <- function(
.x,
method = c("locf", "linear", "spline"),
rule = 2,
na.rm = TRUE,
maxgap = Inf,
...
) {
## TODO
## na.locf() stands for last observation carried forward
## na.approx() uses linear interpolation
## na.spline() uses spline interpolation
method <- match.arg(method)
if (method == "locf") {
y <- zoo::na.locf(.x, rule = rule, na.rm = na.rm, maxgap = maxgap)
} else if (method == "linear") {
y <- zoo::na.approx(.x, rule = rule, na.rm = na.rm, maxgap = maxgap)
} else if (method == "spline") {
y <- zoo::na.spline(.x, na.rm = na.rm, maxgap = maxgap)
}
return(y)
}
replace_missing_data(.x, "spline")
is.na(.x)
which(is.na(.x))
(.x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(.x)
replace_missing_data(.x, "spline")
# zoo::na.locf(.x)
replace_missing_data(.x, "spline", na.rm = FALSE)
# zoo::na.locf(.x)
replace_missing_data(.x, "linear", na.rm = FALSE)
# zoo::na.locf(.x)
replace_missing_data(.x, "linear", rule = 1, na.rm = FALSE)
# zoo::na.locf(.x)
replace_missing_data(.x, "linear", rule = 1, na.rm = TRUE)
is.na(.x)
which(is.na(.x))
# (.x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(.x)
replace_missing_data(.x, "locf", rule = 1, na.rm = TRUE)
# (.x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(.x)
replace_missing_data(.x, "locf", rule = 1, na.rm = FALSE)
# (.x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(.x)
replace_missing_data(.x, "locf", rule = 2, na.rm = FALSE)
# (.x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(.x)
replace_missing_data(.x, "locf", rule = 2, na.rm = TRUE)
#' @param ... Additional arguments.
#'
#' @details
#' For *"locf"*, if there are no earlier non-`NA`s, then the `NA` is either
#' omitted (if `na.rm = TRUE`) or it is not replaced (if `na.rm = FALSE`).
#'
#' @return A list `L` with `L$y` the corrected time series and
#' `L$idx` the indices of the values replaced.
#'
#' @export
replace_missing_data <- function(
x,
method = c("locf", "linear", "spline"),
rule = 2,
na.rm = FALSE,
maxgap = Inf,
...
) {
method <- match.arg(method)
if (method == "locf") {
y <- zoo::na.locf(x, rule = rule, na.rm = na.rm, maxgap = maxgap)
} else if (method == "linear") {
y <- zoo::na.approx(x, rule = rule, na.rm = na.rm, maxgap = maxgap)
} else if (method == "spline") {
y <- zoo::na.spline(x, na.rm = na.rm, maxgap = maxgap)
}
idx <- which(is.na(x))
return(list(y = y, idx = idx))
}
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
replace_missing_data(x, "locf", rule = 2, na.rm = TRUE)
(x <- c(2,NA,1,4,5,2, NA))
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
replace_missing_data(x, "locf", rule = 2, na.rm = TRUE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
replace_missing_data(x, "locf", rule = 1, na.rm = TRUE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
replace_missing_data(x, "locf", rule = 1, na.rm = FALSE)
(x <- c(2,NA,1,4,5,2, NA))
which(is.na(x))
# x.all <- setNames(x, seq_along(x))
na.idx <- which(is.na(x))
na.omit(x)
x.omit <- na.omit(x)
x.omit
as.numeric(names(x.omit[idx]))
as.numeric(names(x.omit[na.idx]))
x.all <- setNames(x, seq_along(x))
na.idx <- which(is.na(x.all))
x.omit <- na.omit(x.all)
as.numeric(names(x.omit[na.idx]))
names(x.omit[na.idx])
x.omit
na.idx
na.idx <- which(is.na(x))
x.omit[na.idx]
x.omit
na.idx
na.idx <- which(is.na(x.all))
x.omit[na.idx]
x.all <- setNames(x, seq_along(x))
na.idx <- which(is.na(x.all))
x.omit <- na.omit(x.all)
x.omit[na.idx]
x.omit
na.idx
x.omit
x.omit
as.numeric(na.omit(x.all))
na.omit(x.all)
x.all <- setNames(x, seq_along(x))
y <- na.omit(x.all)
y
na.omit(x.all)[names(na.omit(x.all))]
na.omit(x.all)
na.omit(x.all)[names(na.omit(x.all))]
#' For *"omit"*, the returned vector `y` will be a named vector with the
#' original indices of each value as names. This allows for preserving and
#' re-inserting the omitted `NA`s back into the final dataset.
#'
#' ...
#'
#' @return A list `L` with `L$y` the corrected time series and
#' `L$idx` the indices of the values replaced.
#'
#' @export
replace_missing_data <- function(
x,
method = c("locf", "linear", "spline", "omit"),
rule = 2,
na.rm = FALSE,
maxgap = Inf,
...
) {
method <- match.arg(method)
if (method == "locf") {
y <- zoo::na.locf(x, rule = rule, na.rm = na.rm, maxgap = maxgap)
} else if (method == "linear") {
y <- zoo::na.approx(x, rule = rule, na.rm = na.rm, maxgap = maxgap)
} else if (method == "spline") {
y <- zoo::na.spline(x, na.rm = na.rm, maxgap = maxgap)
} else if (method == "omit") {
x.all <- setNames(x, seq_along(x))
y <- na.omit(x.all)[names(na.omit(x.all))]
}
idx <- which(is.na(x))
return(list(y = y, idx = idx))
}
(x <- c(2,NA,1,4,5,2, NA))
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
replace_missing_data(x, "locf", rule = 1, na.rm = FALSE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
replace_missing_data(x, "linear", rule = 1, na.rm = FALSE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
replace_missing_data(x, "linear", rule = 1, na.rm = TRUE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
replace_missing_data(x, "linear", rule = 2, na.rm = TRUE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
replace_missing_data(x, "linear", rule = 1, na.rm = TRUE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
replace_missing_data(x, "linear", rule = 2, na.rm = TRUE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
replace_missing_data(x, "linear", rule = 2, na.rm = FALSE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
replace_missing_data(x, "linear", rule = 2, na.rm = TRUE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
replace_missing_data(x, "linear", rule = 1, na.rm = TRUE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
replace_missing_data(x, "linear", rule = 1, na.rm = FALSE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
replace_missing_data(x, "linear", rule = 1, na.rm = FALSE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
replace_missing_data(x, "linear", rule = 1, na.rm = TRUE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
replace_missing_data(x, "linear", rule = 2, na.rm = TRUE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
replace_missing_data(x, "spline", rule = 2, na.rm = TRUE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
replace_missing_data(x, "spline", rule = 2, na.rm = FALSE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
replace_missing_data(x, "spline", rule = 1, na.rm = FALSE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
replace_missing_data(x, "spline", rule = 1, na.rm = TRUE)
zoo::na.spline()
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
# zoo::na.spline()
replace_missing_data(x, "linear", rule = 2, na.rm = TRUE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
# zoo::na.spline()
replace_missing_data(x, "linear", rule = 2, na.rm = FALSE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
# zoo::na.spline()
replace_missing_data(x, "linear", rule = 2, na.rm = FALSE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
# zoo::na.spline()
replace_missing_data(x, "linear", rule = 2, na.rm = FALSE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
# zoo::na.spline()
replace_missing_data(x, "linear", rule = 1, na.rm = FALSE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
# zoo::na.spline()
replace_missing_data(x, "locf", rule = 1, na.rm = FALSE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
# zoo::na.spline()
replace_missing_data(x, "locf", rule = 1, na.rm = TRUE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
# zoo::na.spline()
replace_missing_data(x, "locf", rule = 2, na.rm = TRUE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
# zoo::na.spline()
replace_missing_data(x, "locf", rule = 2, na.rm = FALSE)
#' For *"omit"*, the returned vector `y` will be a named vector with the
#' original indices of each value as names. This allows for preserving and
#' re-inserting the omitted `NA`s back into the final dataset.
#'
#' ...
#'
#' @return A list `L` with `L$y` the corrected time series and
#' `L$idx` the indices of the values replaced.
#'
#' @export
replace_missing_data <- function(
x,
method = c("locf", "linear", "spline", "omit"),
na.rm = FALSE,
maxgap = Inf,
...
) {
method <- match.arg(method)
if (method == "locf") {
y <- zoo::na.locf(x, na.rm = na.rm, maxgap = maxgap)
} else if (method == "linear") {
rule <- ifelse(na.rm, 2, 1)
y <- zoo::na.approx(x, rule = rule, na.rm = na.rm, maxgap = maxgap)
} else if (method == "spline") {
y <- zoo::na.spline(x, na.rm = na.rm, maxgap = maxgap)
} else if (method == "omit") {
x.all <- setNames(x, seq_along(x))
y <- na.omit(x.all)[names(na.omit(x.all))]
}
idx <- which(is.na(x))
return(list(y = y, idx = idx))
}
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
# zoo::na.spline()
replace_missing_data(x, "omit", na.rm = FALSE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
# zoo::na.spline()
replace_missing_data(x, "linear", na.rm = FALSE)
# (x <- c(2,NA,1,4,5,2, NA))
# zoo::na.locf(x)
# zoo::na.spline()
replace_missing_data(x, "linear", na.rm = TRUE)
