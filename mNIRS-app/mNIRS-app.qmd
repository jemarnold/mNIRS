---
title: "mNIRS Processing"
date: last-modified
language: 
    title-block-published: "App Updated"
author:
    - name: Jem Arnold
      orcid: 0000-0003-3908-9447
      email: jem.arnold@ubc.ca
format: 
    dashboard:
        nav-buttons: 
            - icon: twitter
              href: https://x.com/jem_arnold
            - icon: github
              href: https://github.com/jemarnold
server: shiny
editor: source
execute:
    echo: false
    message: false
    warning: false
    output: true
---

```{r}
#| context: setup

## install latest private repo from github
# devtools::install_github(
#     "jemarnold/mNIRS",
#     auth_token = "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")

suppressPackageStartupMessages({
    library(bslib)
    library(shiny)
    library(DT)
    library(mNIRS)
    library(tidyverse)
})

options(digits = 5, digits.secs = 3, scipen = 3,
        dplyr.summarise.inform = FALSE,
        tibble.print_min = 20,
        shiny.maxRequestSize = 50*1024^2)

string_to_named_vector <- function(x) {
    noquotes <- gsub('["\\\"]', '', x)
    split_vec <- unlist(strsplit(noquotes, "\\s*,\\s*"))
    split_list <- strsplit(split_vec, "\\s*=\\s*")
    setNames(sapply(split_list, \(.x) trimws(.x[2])),
             sapply(split_list, \(.x) trimws(.x[1])))
}


```


# Plot

## User Input {.sidebar}

```{r setup}


## TODO 
## instructions
## action button
## split into laps by Lap/Event column
## -- either from one non-NA event value to the next, 
## -- or for all same lap values
## export laps to excel sheets
## kinetics stuff

br()

## Upload file
fileInput(
    "upload_file",
    label = NULL,
    buttonLabel = "Upload File",
    accept = c('.xlsx', '.xls', '.csv', '.CSV'),
)

## Tell it which columns are which
textInput(
    "nirs_columns", 
    label = "NIRS Channel Names (multiple)", 
    placeholder = "newname = oldname")
textInput(
    "sample_column", 
    label = "Sample Column Name (single)", 
    placeholder = "newname = oldname")
textInput(
    "event_column", 
    label = "Lap/Event Column Name (single)", 
    placeholder = "newname = oldname")

numericInput("sample_rate", label = "Sample Rate", value = 0)

numericInput("downsample_rate", label = "Downsample Rate", value = 0)

## remove head/tail samples
numericInput("slice_head", label = "Remove head samples", value = 0, step = 1)
numericInput("slice_tail", label = "Remove tail samples", value = 0, step = 1)

## Replace fixed values (column wise)
textInput(
    "fixed_values",
    label = "Replace Fixed Values",
    placeholder = "0, 100, ...")

## Replace outliers (column wise)
checkboxInput("replace_outliers", "Replace outliers")

## Replace missing values (column wise)
checkboxInput("replace_missing", "Replace missing values", value = TRUE)

## Filter/smooth data (column wise)
selectInput(
    "filter_method",
    label = "Digital Filter Method",
    choices = c("none", "smooth-spline", "butterworth", "moving-average"))
uiOutput("filter_method_ui")

## Shift data (dataframe)
checkboxInput("shift_logical", "Shift Data")
uiOutput("shift_data_ui")

## rescale (dataframe)
checkboxInput("rescale_logical", "Rescale Data")
uiOutput("rescale_data_ui")

checkboxInput("keep_all", "Keep all columns in file export")

downloadButton("download_data", "Download Data")

```

## Plot

```{r}

plotOutput("plot")
```

# Data

```{r}

DT::DTOutput("nirs_table")
```

# Kinetics

## User Input {.sidebar}

```{r}

cat("Under Development")
## Slice into laps/events (lapwise list of dataframes)
## Start & end of work with padding to each side
## Define work baseline; end-work mean; reoxygenation peak (lapwise)
## Process reoxy kinetics (lapwise)
## Generate plots (lapwise)

```



# Instructions

`r cat("Under Development")`

## Instructions

**Upload File:**
Upload an `.xlsx`, `.xls`, or `.csv` file.

**Channel Names:**
Enter the names for the mNIRS data channels, Sample column, and Lap/Event column. Data channels can be renamed with the format `newname = oldname`. Original column names must match the file strings exactly. Separate multiple names as `newname1 = oldname1, newname2 = oldname2`.

For example, from a *Moxy* .csv file: `NIRS Channel Names = "smo2_left  = SmO2 Live"; Sample Column Name = "time = hh:mm:ss"; [Lap/Event column left blank]`.

**Sample Rate:**
Will be estimated automatically from the data, or can be entered explicitly. This is required for certain functions, including proper digital filtering. Check the exported file sample times to confirm.

**Downsample Rate:**
Can be defined to downsample the data and reduce the number of output samples to improve signal to noise ratio.

**Remove Head/Tail Samples:**
Will remove samples from the start and end of the data. This can be used to omit erroneous data at the head/tail, or to include only a particular selection of the entire data file. `<under development: interactive graphical method to select portions of data>`

**Replace Outliers:**
Will replace local outliers using a `Hampel` filter.

**Replace Missing Values:**
Will interpolate across missing (`NA`) samples.

**Replace Fixed Values:**
A vector of numeric values can be defined to be explicitly removed and interpolated across, such as `c(0, 100)` when mNIRS sensors return erroneous values.

**Digital Filter Method:**
Choose a digital filter method from the drop-down options. The simplest option that works well for many datasets is a non-parametric `smooth-spline`. 

A `Butterworth` filter can be defined to optimise the signal-to-noise ratio for your particular signal. The most common `Filter Type` is *"low-pass"*. `Filter Order (n)` should be an integer, typically between `[1:8]`. Critical Frequency should be a numeric value between `0` and half of the sample rate, in Hz.

`<under development: interactive graphical method to compare digital filter methods>`

**Shift Data:**
Will shift mNIRS channels either together (with `Channels to Shift = "ensemble"`) or separately (with `distinct`) to the value specified by `Value to Shift`. `Position to Shift` defines which reference values from the data channel(s) to shift. `Samples to Shift` defines over how many samples to shift the mean value. 

For example, each mNIRS channel can be shifted so that the first 30-sec mean value begins at zero, with the settings: `Value to Shift = 0; Channels to Shift = "distinct"; Position to Shift = "first"; Samples to Shift = [30 * Sample Rate]` (where the value representing `[30 * Sample Rate]` should be manually entered).

**Rescale Data:**
Will re-scale the mNIRS channels either together (`Channels to Rescale = "ensemble"`) or separately (with `distinct`) to the data range specified by `Rescale Range Minimum/Maximum`. 

For example, all present mNIRS channels can be re-scaled so that the range of data are within range of 0% to 100%, preserving the relative scaling of each channel to the other, with the settings: `Rescale Range Minimum = 0; Rescale Range Maximum = 100; Channels to Rescale = "ensemble"`.

**Keep all columns in file export:**
Will keep all columns present from the original data file when exporting the processed file, along with the nirs, sample, and lap/event columns specified explicitly.

**Download Data:**
Will open a dialogue box to save an `.xlsx` file with the processed data to your system.

**Plot Tab:**
Specified mNIRS channels will be displayed in the `Plot` window and updated according to manually entered processing parameters.

**Data Tab:** 
Processed data can be viewed in the `Data` window and will be updated according to the manually entered processing parameters.

**Kinetics Tab:** `<under development>`




```{r}
#| context: server

nirs_columns_debounced <- debounce(reactive(input$nirs_columns), 2000)
sample_column_debounced <- debounce(reactive(input$sample_column), 2000)
event_column_debounced <- debounce(reactive(input$event_column), 2000)

# Data upload and processing
raw_data <- reactive({
    req(input$upload_file, nirs_columns_debounced(), sample_column_debounced())
    
    upload_file <- input$upload_file$datapath
    # upload_file <- r"(C:\R-Projects\mNIRS\inst\extdata\train.red_interval_example.csv)"
    # upload_file <- r"(C:\R-Projects\mNIRS\inst\extdata\oxysoft_interval_example.xlsx)"
    
    data <- mNIRS::read_data(
        file_path = upload_file,
        # nirs_columns = string_to_named_vector(c(
        #     "smo2_left  = SmO2 unfiltered",
        #     "smo2_right = SmO2 unfiltered")),
        # sample_column = string_to_named_vector(
        #     "time = Timestamp (seconds passed)"),
        nirs_columns = string_to_named_vector(nirs_columns_debounced()),
        sample_column = string_to_named_vector(sample_column_debounced()),
        event_column = string_to_named_vector(event_column_debounced()),
        sample_rate = input$sample_rate,
        numeric_time = TRUE,
        keep_all = input$keep_all,
        verbose = FALSE)
    
    # raw_data <- mNIRS::read_data(
    #     upload_file,
    #     nirs_columns = c(smo2_left = "SmO2 unfiltered",
    #                      smo2_right = "SmO2 unfiltered"),
    #     sample_column = c(time = "Timestamp (seconds passed)"),
    #     # event_column = c(event = "...11"),
    #     keep_all = FALSE)
    
    return(data)
})

## Create dynamic UI for filter method
output$filter_method_ui <- renderUI({
    req(raw_data(), input$filter_method,
        nirs_columns_debounced(), sample_column_debounced())
    
    raw_data <- raw_data()
    sample_rate <- attributes(raw_data)$sample_rate
    
    # Different UI based on selection
    if (input$filter_method == "butterworth") {
        tagList(
            selectInput(
                "butter_type",
                label = "Butterworth Filter Type",
                choices = c("low", "high", "stop", "pass")
            ),
            numericInput(
                "n",
                label = "Filter Order (n)",
                value = 2,
                min = 1,
                max = 10,
                step = 1
            ),
            # numericInput(
            #   "W",
            #   label = "Fractional Critical Frequency (W)",
            #   value = 0.1,
            #   min = 0,
            #   max = 1,
            #   step = 0.01
            # ),
            numericInput(
                "critical_frequency",
                label = "Critical Frequency (Hz)",
                value = 0.1,
                min = 0,
                max = sample_rate/2,
                step = 0.05
            )
        )
    } else if (input$filter_method == "moving-average") {
        tagList(
            numericInput(
                "width",
                label = "width",
                value = 15,
                min = 1,
                step = 1
            )
        )
    } else {
        NULL
    }
})

## Create dynamic UI for shift option
output$shift_data_ui <- renderUI({
    req(raw_data(), input$shift_logical,
        nirs_columns_debounced(), sample_column_debounced())
    
    # Different UI based on selection
    if (input$shift_logical) {
        tagList(
            numericInput(
                "shift_value",
                label = "Value to Shift",
                value = 0),
            selectInput(
                "shift_which_cols",
                label = "Channels to Shift",
                choices = c("ensemble", "distinct")),
            selectInput(
                "shift_position",
                label = "Position to Shift",
                choices = c("minimum", "maximum", "first")),
            numericInput(
                "shift_samples",
                label = "Samples to Shift",
                value = 1),
        )
    }
})

## Create dynamic UI for rescale option
output$rescale_data_ui <- renderUI({
    req(raw_data(), input$rescale_logical,
        nirs_columns_debounced(), sample_column_debounced())
    
    # Different UI based on selection
    if (input$rescale_logical) {
        tagList(
            numericInput(
                "rescale_min",
                label = "Rescale Range Minimum",
                value = 0),
            numericInput(
                "rescale_max",
                label = "Rescale Range Maximum",
                value = 100),
            selectInput(
                "rescale_which_cols",
                label = "Channels to Rescale",
                choices = c("ensemble", "distinct")),
        )
    }
})

nirs_data <- reactive({
    req(raw_data(), nirs_columns_debounced(), sample_column_debounced())
    
    raw_data <- raw_data()
    nirs_columns <- attributes(raw_data)$nirs_columns
    sample_column <- attributes(raw_data)$sample_column
    sample_rate <- attributes(raw_data)$sample_rate
    fixed_values <- strsplit(input$fixed_values, split = "\\s*,\\s*")[[1]] |> 
        as.numeric()
    
    nirs_data <- raw_data |> 
        mNIRS::downsample_data(
            data = _,
            sample_column = sample_column,
            sample_rate = sample_rate,
            downsample_rate = input$downsample_rate,
            verbose = FALSE
        ) |> 
        ## remove the head rows
        (\(.df) if (input$slice_head > 0) {
            slice_tail(.data = .df, n = -input$slice_head)
        } else {.df})() |> 
        ## remove the tail rows
        (\(.df) if (input$slice_tail > 0) {
            slice_head(.data = .df, n = -input$slice_tail)
        } else {.df})() |> 
        mutate(
            if (input$replace_outliers) {
                across(
                    any_of(nirs_columns),
                    \(.x) mNIRS::replace_outliers(.x, width = sample_rate))
            },
            if (!is.null(fixed_values)) {
                across(
                    any_of(nirs_columns),
                    \(.x) mNIRS::replace_fixed_values(
                        .x, fixed_values, width = sample_rate, return = "median"))
            },
            if (input$replace_missing) {
                across(
                    any_of(nirs_columns),
                    \(.x) mNIRS::replace_missing_values(
                        .x, method = "linear", na.rm = TRUE))
            },
            if (input$filter_method == "smooth-spline") {
                across(
                    any_of(nirs_columns),
                    \(.x) mNIRS::filter_data(
                        .x, method = input$filter_method))
            } else if (input$filter_method == "butterworth") {
                req(input$n, input$critical_frequency)
                
                across(
                    any_of(nirs_columns),
                    \(.x) mNIRS::filter_data(
                        .x, method = "butter", 
                        type = input$butter_type,
                        n = input$n,
                        critical_frequency = input$critical_frequency,
                        sample_rate = sample_rate))
            } else if (input$filter_method == "moving-average") {
                req(input$width)
                
                across(
                    any_of(nirs_columns),
                    \(.x) mNIRS::filter_data(
                        .x, method = input$filter_method, 
                        width = input$width))
            },
        ) |> 
        (\(.df) if (input$shift_logical) {
            req(input$shift_value, input$shift_position, 
                input$shift_which_cols, input$shift_samples)
            
            if (input$shift_which_cols == "ensemble") {
                shift_nirs_columns <- nirs_columns
            } else if (input$shift_which_cols == "distinct") {
                shift_nirs_columns <- as.list(nirs_columns)
            }
            
            mNIRS::shift_data(
                data = .df,
                nirs_columns = shift_nirs_columns,
                shift_to = input$shift_value,
                position = input$shift_position,
                mean_samples = input$shift_samples,
            )
        } else {.df})() |> 
        (\(.df) if (input$rescale_logical) {
            req(input$rescale_min, input$rescale_max, 
                input$rescale_which_cols)
            
            if (input$rescale_which_cols == "ensemble") {
                rescale_nirs_columns <- nirs_columns
            } else if (input$rescale_which_cols == "distinct") {
                rescale_nirs_columns <- as.list(nirs_columns)
            }
            
            mNIRS::rescale_data(
                data = .df,
                nirs_columns = rescale_nirs_columns,
                rescale_range = c(input$rescale_min, input$rescale_max)
            )
        } else {.df})() |> 
        mutate(
            across(any_of(nirs_columns), \(.x) round(.x, 2))
        )
    
    return(nirs_data)
    
})


output$nirs_table <- DT::renderDT({
    req(nirs_data())
    
    nirs_columns <- attributes(nirs_data)$nirs_columns
    
    table <- DT::datatable(
        nirs_data(),
        options = list(
            pageLength = 25,
            scrollX = TRUE,
            searchHighlight = TRUE
        ))
    
    return(table)
})



output$plot <- renderPlot({
    req(nirs_data(), nirs_columns_debounced(), sample_column_debounced())
    
    nirs_data <- nirs_data()
    
    plot(nirs_data)
    
})



output$download_data <- downloadHandler(
    
    filename = function() {
        paste0("mNIRS_processed_", Sys.time(), ".xlsx")
    },
    
    content = function(file) {
        writexl::write_xlsx(nirs_data(), path = file)
    }
)

```

